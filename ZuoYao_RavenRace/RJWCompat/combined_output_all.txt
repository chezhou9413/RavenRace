=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\About\About.xml
=

<?xml version="1.0" encoding="utf-8"?>
<ModMetaData>
    <name>Raven Race - RJW Compatibility (Internal)</name>
    <author>ZuoYao</author>
    <packageId>ZuoYao.RavenRace.RJWCompat</packageId>
    <supportedVersions>
        <li>1.6</li>
    </supportedVersions>
    <description>RJW and Menstruation Cycle compatibility for Raven Race. Loaded via LoadFolders.xml.</description>
</ModMetaData>

=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Patches\Patch_RavenDNA.xml
=
.
<?xml version="1.0" encoding="utf-8"?>
<Patch>
    <Operation Class="PatchOperationAddModExtension">
        <xpath>/Defs/AlienRace.ThingDef_AlienRace[defName="Raven_Race"]</xpath>
        <value>
            <!-- 为渡鸦族添加RJW月经周期所需的DNA信息 -->
            <li Class="RJW_Menstruation.PawnDNAModExtension">
                <!-- 胎儿贴图路径，我们是卵生，但为了兼容性最好提供一个占位符 -->
                <fetusTexPath>Fetus/Fetus_Default</fetusTexPath>
                <!-- 精液颜色 (RGBA) -->
                <cumColor>(255,255,255,255)</cumColor> 
                <!-- 精液粘稠度 -->
                <cumThickness>0.2</cumThickness>
                <!-- 我们没有特殊的摄入效果 -->
                <ingestionOutcomeDoers />
                <!-- 我们不使用RJW的杂交系统，留空 -->
                <hybridExtension />
            </li>
        </value>
    </Operation>
</Patch>.
.
=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Source\RJWCompat\Patch_ForceLovin.cs
=
.
﻿using HarmonyLib;
using RimWorld;
using Verse;
using RavenRace.RJWCompat.UI;
using RavenRace.Features.Reproduction; // 引用主模组的繁殖命名空间

namespace RavenRace.RJWCompat
{
    [HarmonyPatch("RavenRace.CompAbilityEffect_ForceLovin", "Apply")]
    public static class Patch_ForceLovin_Apply
    {
        [HarmonyPrefix]
        public static bool Prefix(LocalTargetInfo target, CompAbilityEffect __instance)
        {
            Log.Message($"[RavenRace RJWCompat] 'ForceLovin.Apply' Prefix patch triggered!");

            Pawn caster = __instance.parent.pawn;
            Pawn targetPawn = target.Pawn;
            if (caster == null || targetPawn == null) return false;

            // [修改] 新增逻辑：如果开启了RJW兼容模式，则在使用技能时立即触发渡鸦怀孕
            if (RavenRaceMod.Settings.rjwRavenPregnancyCompat)
            {
                // 调用一个独立的辅助方法来处理怀孕逻辑，保持代码整洁
                AttemptRavenPregnancyImmediately(caster, targetPawn);
            }

            // 无论是否触发怀孕，都弹出RJW互动选择窗口
            Find.WindowStack.Add(new Dialog_SelectRjwInteraction(caster, targetPawn));

            // 阻止原版的 ForceLovin Job 创建
            return false;
        }

        /// <summary>
        /// [新增] 立即尝试触发渡鸦灵卵怀孕的辅助方法。
        /// </summary>
        private static void AttemptRavenPregnancyImmediately(Pawn caster, Pawn partner)
        {
            Pawn carrier = null;
            Pawn donor = null;

            bool isMechanoidInvolved = caster.RaceProps.IsMechanoid || partner.RaceProps.IsMechanoid;
            bool isSameSex = caster.gender == partner.gender;

            // 确定载体和供体 (逻辑与 JobDriver_ForceLovin 一致)
            if (isMechanoidInvolved)
            {
                if (!caster.RaceProps.IsMechanoid) carrier = caster;
                else if (!partner.RaceProps.IsMechanoid) carrier = partner;
                if (carrier == null) return;
                donor = (carrier == caster) ? partner : caster;
            }
            else if (isSameSex && (RavenRaceMod.Settings.enableSameSexForceLovin || RavenRaceMod.Settings.enableMalePregnancyEgg))
            {
                donor = caster;
                carrier = partner;
            }
            else
            {
                carrier = (caster.gender == Gender.Female) ? caster : partner;
                donor = (carrier == caster) ? partner : caster;
            }

            if (carrier == null || donor == null) return;
            if (carrier.gender == Gender.Male && !RavenRaceMod.Settings.enableMalePregnancyEgg) return;

            // 只有至少一方是渡鸦族，才进行灵卵怀孕
            bool isCarrierRaven = carrier.def == RavenDefOf.Raven_Race;
            bool isDonorRaven = donor.def == RavenDefOf.Raven_Race;
            if (!isCarrierRaven && !isDonorRaven) return;

            // 检查概率
            if (!Rand.Chance(RavenRaceMod.Settings.forcedLovinPregnancyRate)) return;

            // 获取基因
            GeneSet genes;
            if (isMechanoidInvolved)
            {
                genes = new GeneSet();
                if (carrier.genes != null)
                {
                    foreach (var g in carrier.genes.GenesListForReading) genes.AddGene(g.def);
                    genes.SetNameDirect("机械混血");
                }
            }
            else
            {
                // [修正] 直接接收返回的 GeneSet 对象
                genes = PregnancyUtility.GetInheritedGeneSet(donor, carrier, out bool success);
                if (!success) return;
            }

            // 创建并添加Hediff
            var hediff = (HediffRavenPregnancy)HediffMaker.MakeHediff(RavenDefOf.Raven_Hediff_RavenPregnancy, carrier);
            hediff.Initialize(donor, genes, RavenRaceMod.Settings.forceRavenDescendant);
            carrier.health.AddHediff(hediff);
            carrier.Drawer?.renderer?.SetAllGraphicsDirty();

            Messages.Message($"{carrier.LabelShortCap} 在互动前已被强制注入了一枚渡鸦灵卵。", carrier, MessageTypeDefOf.PositiveEvent);
        }
    }
}.
.
=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Source\RJWCompat\Patch_Menstruation.cs
=
.
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using HarmonyLib;
using RimWorld;
using Verse;
using RavenRace.Features.Reproduction; // [核心修复] 引用新的命名空间

namespace RavenRace.RJWCompat
{
    [HarmonyPatch]
    public static class Patch_Menstruation_Implant
    {
        // 使用字符串名称进行延迟绑定，防止RJW未加载时直接崩溃
        public static MethodBase TargetMethod()
        {
            return AccessTools.Method("RJW_Menstruation.HediffComp_Menstruation:Implant");
        }

        [HarmonyPrefix]
        public static bool Prefix(HediffComp __instance)
        {
            // 如果反射初始化失败，直接跳过
            if (!RjwReflection.IsInitialized) return true;

            // 通过反射安全地获取字段值
            var eggsList = RjwReflection.Menstruation_eggs_Field.GetValue(__instance) as IList;
            if (eggsList == null || eggsList.Count == 0) return true;

            object fertilizedEgg = null;
            foreach (var egg in eggsList)
            {
                bool isFertilized = (bool)RjwReflection.Egg_fertilized_Field.GetValue(egg);
                object fertilizer = RjwReflection.Egg_fertilizer_Field.GetValue(egg);
                if (isFertilized && fertilizer != null)
                {
                    fertilizedEgg = egg;
                    break;
                }
            }

            if (fertilizedEgg == null) return true;

            Pawn mother = __instance.Pawn;
            Pawn father = RjwReflection.Egg_fertilizer_Field.GetValue(fertilizedEgg) as Pawn;

            // --- 判定是否应该产卵 (逻辑与主模组一致) ---
            bool shouldLayEgg = false;

            // 1. 获取设置
            var settings = RavenRaceMod.Settings;

            // 2. 男性生子(蛋)逻辑
            if (settings.enableMalePregnancyEgg && mother.gender == Gender.Male)
            {
                if (mother.def.defName == "Raven_Race" || (father != null && father.def.defName == "Raven_Race"))
                {
                    shouldLayEgg = true;
                }
            }
            // 3. 渡鸦母亲
            else if (mother.def.defName == "Raven_Race")
            {
                shouldLayEgg = true;
            }
            // 4. 父系决定逻辑
            else if (settings.ravenFatherDeterminesEgg && father != null && father.def.defName == "Raven_Race")
            {
                shouldLayEgg = true;
            }

            if (!shouldLayEgg) return true;

            try
            {
                Log.Message("[RavenRace RJWCompat] Intercepting RJW pregnancy, creating Spirit Egg hediff...");

                bool success;
                List<GeneDef> inheritedGenesList = PregnancyUtility.GetInheritedGenes(father, mother, out success);
                if (!success)
                {
                    // 仅作为警告，不阻止流程
                    // Log.Warning($"[RavenRace RJWCompat] Failed to get inherited genes.");
                }
                GeneSet inheritedGeneSet = new GeneSet();
                foreach (var g in inheritedGenesList) inheritedGeneSet.AddGene(g);

                if (father != null && GeneUtility.SameHeritableXenotype(father, mother))
                {
                    inheritedGeneSet.SetNameDirect(father.genes?.xenotypeName);
                }

                // [核心修复] 使用新的类名 HediffRavenPregnancy，并使用 DefOf 获取 Def
                var hediff = HediffMaker.MakeHediff(RavenDefOf.Raven_Hediff_RavenPregnancy, mother) as HediffRavenPregnancy;

                if (hediff != null)
                {
                    hediff.Initialize(father, inheritedGeneSet, settings.forceRavenDescendant);
                    mother.health.AddHediff(hediff);
                    mother.Drawer?.renderer?.SetAllGraphicsDirty();
                }

                // 清空原版月经Mod的卵子列表，防止双重怀孕
                eggsList.Clear();

                Messages.Message($"{mother.LabelShort} has conceived a spirit egg (RJW-compatible).", mother, MessageTypeDefOf.PositiveEvent);

                // 返回 false 阻止原方法执行（即阻止RJW的原版怀孕逻辑）
                return false;
            }
            catch (Exception e)
            {
                Log.Error($"[RavenRace RJWCompat] Error during spirit egg conception interception: {e}");
                return true;
            }
        }
    }
}.
.
=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Source\RJWCompat\Patch_RJW_AfterSex.cs
=
.
﻿using System.Net;
using HarmonyLib;
using RavenRace.Features.DegradationCharm; // 引用淫堕符咒相关定义
using RimWorld;
using rjw; // 必须引用 RJW
using UnityEngine;
using Verse;

namespace RavenRace.RJWCompat
{
    /// <summary>
    /// RJW 性爱结算补丁
    /// 作用：
    /// 1. 恢复因拦截 Raven_Job_ForceLovin 而丢失的“降低抵抗/意志”逻辑。
    /// 2. 恢复因未使用 JobDriver_Lovin 而丢失的“增加淫堕条”逻辑。
    /// </summary>
    [HarmonyPatch(typeof(SexUtility), "Aftersex")]
    public static class Patch_RJW_AfterSex
    {
        [HarmonyPostfix]
        public static void Postfix(SexProps props)
        {
            // 安全检查
            if (props == null || props.pawn == null || props.partner == null) return;

            Pawn initiator = props.pawn; // 发起者 (渡鸦)
            Pawn partner = props.partner; // 承受者 (可能是囚犯)

            // ------------------------------------------------------
            // 1. 处理“淫堕刻印” (Degradation Charm) 增加逻辑
            // ------------------------------------------------------
            IncreaseDegradationIfPresent(initiator);
            IncreaseDegradationIfPresent(partner);

            // ------------------------------------------------------
            // 2. 处理“强制求爱”带来的囚犯互动 (降低抵抗/意志)
            // ------------------------------------------------------
            // 条件：发起者是渡鸦族 (或拥有该能力)，且对象是本殖民地的囚犯
            // 注意：因为我们无法轻易区分这是 "ForceLovin" 还是普通的 RJW 性爱，
            // 这里我们假设只要是渡鸦族发起的对囚犯的性行为，都视作这种互动。
            if (initiator.def == RavenDefOf.Raven_Race && partner.IsPrisonerOfColony)
            {
                HandleRavenPrisonerInteraction(initiator, partner);
            }
        }

        /// <summary>
        /// 增加淫堕 Hediff 的严重度
        /// </summary>
        private static void IncreaseDegradationIfPresent(Pawn pawn)
        {
            if (pawn == null || pawn.Dead) return;

            // 使用 DefOf 获取 HediffDef
            Hediff hediff = pawn.health.hediffSet.GetFirstHediffOfDef(DegradationCharmDefOf.Raven_Hediff_Degradation);
            if (hediff != null)
            {
                // 每次 RJW 性行为增加 0.1
                hediff.Severity += 0.10f;
            }
        }

        /// <summary>
        /// 处理囚犯互动逻辑 (从 JobDriver_ForceLovin 移植并适配)
        /// </summary>
        private static void HandleRavenPrisonerInteraction(Pawn initiator, Pawn prisoner)
        {
            var s = RavenRaceMod.Settings;
            if (s == null) return;
            bool graphicsDirty = false;

            // A. 招募模式 -> 降抵抗
            if (prisoner.guest.ExclusiveInteractionMode == PrisonerInteractionModeDefOf.AttemptRecruit && prisoner.guest.resistance > 0)
            {
                float reduction = s.forceLovinResistanceReduction;
                prisoner.guest.resistance = Mathf.Max(0, prisoner.guest.resistance - reduction);
                Messages.Message("RavenRace_Msg_ResistanceLowered".Translate(prisoner.LabelShort, reduction), prisoner, MessageTypeDefOf.PositiveEvent);

                // 瞬间招募判定
                if (prisoner.guest.resistance <= 0 && Rand.Chance(s.forceLovinInstantRecruitChance))
                {
                    InteractionWorker_RecruitAttempt.DoRecruit(initiator, prisoner);
                    AddDominatedRelation(prisoner, initiator);
                    Messages.Message("RavenRace_Msg_InstantRecruit".Translate(prisoner.LabelShort), prisoner, MessageTypeDefOf.PositiveEvent);
                    graphicsDirty = true;
                }
            }
            // B. 奴役模式 -> 降意志
            else if (prisoner.guest.ExclusiveInteractionMode == PrisonerInteractionModeDefOf.Enslave && prisoner.guest.will > 0)
            {
                float reduction = s.forceLovinWillReduction;
                prisoner.guest.will = Mathf.Max(0, prisoner.guest.will - reduction);
                Messages.Message("RavenRace_Msg_WillLowered".Translate(prisoner.LabelShort, reduction), prisoner, MessageTypeDefOf.PositiveEvent);

                // 瞬间奴役判定
                if (prisoner.guest.will <= 0 && Rand.Chance(s.forceLovinInstantRecruitChance))
                {
                    GenGuest.EnslavePrisoner(initiator, prisoner);
                    AddDominatedRelation(prisoner, initiator);
                    Messages.Message("RavenRace_Msg_InstantEnslave".Translate(prisoner.LabelShort), prisoner, MessageTypeDefOf.PositiveEvent);
                    graphicsDirty = true;
                }
            }
            // C. 转化模式 -> 降信仰
            else if (ModsConfig.IdeologyActive && prisoner.guest.ExclusiveInteractionMode == PrisonerInteractionModeDefOf.Convert && prisoner.Ideo != initiator.Ideo)
            {
                prisoner.ideo.OffsetCertainty(-s.forceLovinCertaintyReduction);
            }

            // D. 打破死忠
            if (!prisoner.guest.Recruitable && Rand.Chance(s.forceLovinBreakLoyaltyChance))
            {
                prisoner.guest.Recruitable = true;
                prisoner.guest.SetExclusiveInteraction(PrisonerInteractionModeDefOf.AttemptRecruit);
                Messages.Message("RavenRace_Msg_LoyaltyBroken".Translate(prisoner.LabelShort), prisoner, MessageTypeDefOf.PositiveEvent);
                graphicsDirty = true;
            }

            if (graphicsDirty)
            {
                prisoner.Drawer?.renderer?.SetAllGraphicsDirty();
            }
        }

        private static void AddDominatedRelation(Pawn subject, Pawn master)
        {
            if (subject != null && master != null)
            {
                subject.relations.AddDirectRelation(RavenDefOf.Raven_Relation_Dominated, master);
            }
        }
    }
}.
.
=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Source\RJWCompat\RJWCompat_Startup.cs
=
.
﻿using HarmonyLib;
using System.Collections.Generic; // [修正] 需要引用 Generic 集合
using System.Reflection;
using Verse;

namespace RavenRace.RJWCompat
{
    // 这个类不再需要 [StaticConstructorOnStartup]，因为它是由主模组动态调用的
    public static class RJWCompat_Startup
    {
        /// <summary>
        /// 这个公共静态方法是整个兼容模块的入口点。
        /// 它由主模组的启动器在确认RJW已加载后，通过反射来调用。
        /// </summary>
        public static void ApplyPatches()
        {
            // 修改为（加上 HarmonyLib. 前缀）：
            var harmony = new HarmonyLib.Harmony("ZuoYao.RavenRace.RJWCompat");

            Log.Message("[RavenRace RJWCompat] ApplyPatches() called by main module. Applying patches now...");

            // [最终修复] 手动应用整个程序集的补丁，这是最标准和可靠的方式。
            // Harmony 会自动扫描这个DLL里的所有 [HarmonyPatch] 标签并应用它们。
            harmony.PatchAll(Assembly.GetExecutingAssembly());

            Log.Message("[RavenRace RJWCompat] All patches from RJWCompat assembly have been applied.");

            // 在所有补丁都应用完毕后，安全地初始化反射缓存。
            // 这个时候去查找RJW的类型是100%安全的。
            RjwReflection.Initialize();
        }
    }
}.
.
=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Source\RJWCompat\RjwReflection.cs
=
.
﻿// File: RJWCompat/Source/RJWCompat/RjwReflection.cs
using HarmonyLib;
using System;
using System.Reflection;
using Verse;

namespace RavenRace.RJWCompat
{
    /// <summary>
    /// 存储通过反射获取的RJW类型、方法和字段的缓存。
    /// 仅保留月经补丁所需的部分。
    /// </summary>
    public static class RjwReflection
    {
        // Types
        public static Type HediffComp_Menstruation_Type { get; private set; }
        public static Type Egg_Type { get; private set; }

        // Fields
        public static FieldInfo Menstruation_eggs_Field { get; private set; }
        public static FieldInfo Egg_fertilized_Field { get; private set; }
        public static FieldInfo Egg_fertilizer_Field { get; private set; }

        public static bool IsInitialized { get; private set; } = false;

        public static void Initialize()
        {
            if (IsInitialized) return;

            Log.Message("[RavenRace RJWCompat] RjwReflection.Initialize() called.");

            // 寻找关键类型
            HediffComp_Menstruation_Type = AccessTools.TypeByName("RJW_Menstruation.HediffComp_Menstruation");

            if (HediffComp_Menstruation_Type == null)
            {
                Log.Error("[RavenRace RJWCompat] FATAL: RJW_Menstruation.HediffComp_Menstruation type not found. Cannot initialize reflection cache for Menstruation patch.");
                return;
            }

            // 寻找嵌套类型和字段
            Egg_Type = AccessTools.Inner(HediffComp_Menstruation_Type, "Egg");
            if (Egg_Type == null)
            {
                Log.Error("[RavenRace RJWCompat] FATAL: 'Egg' nested type not found in HediffComp_Menstruation.");
                return;
            }

            Menstruation_eggs_Field = AccessTools.Field(HediffComp_Menstruation_Type, "eggs");
            Egg_fertilized_Field = AccessTools.Field(Egg_Type, "fertilized");
            Egg_fertilizer_Field = AccessTools.Field(Egg_Type, "fertilizer");

            // 验证字段是否找到
            if (Menstruation_eggs_Field == null || Egg_fertilized_Field == null || Egg_fertilizer_Field == null)
            {
                Log.Error("[RavenRace RJWCompat] FATAL: One or more fields required for menstruation patch were not found via reflection.");
                return;
            }

            IsInitialized = true;
            Log.Message("[RavenRace RJWCompat] Reflection cache for RJW types initialized successfully.");
        }
    }
}.
.
=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Source\RJWCompat\obj\Debug\.NETFramework,Version=v4.7.2.AssemblyAttributes.cs
=
.
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.7.2", FrameworkDisplayName = ".NET Framework 4.7.2")]
.
.
=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Source\RJWCompat\obj\Debug\.NETFramework,Version=v4.8.AssemblyAttributes.cs
=
.
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]
.
.
=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Source\RJWCompat\Properties\AssemblyInfo.cs
=
.
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 有关程序集的一般信息由以下
// 控制。更改这些特性值可修改
// 与程序集关联的信息。
[assembly: AssemblyTitle("RJWCompat")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("RJWCompat")]
[assembly: AssemblyCopyright("Copyright ©  2026")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// 将 ComVisible 设置为 false 会使此程序集中的类型
//对 COM 组件不可见。如果需要从 COM 访问此程序集中的类型
//请将此类型的 ComVisible 特性设置为 true。
[assembly: ComVisible(false)]

// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID
[assembly: Guid("b09f150d-3554-4c13-a073-cb767c282e48")]

// 程序集的版本信息由下列四个值组成: 
//
//      主版本
//      次版本
//      生成号
//      修订号
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
.
.
=
File: C:\Users\Administrator\Desktop\RavenRace\ZuoYao_RavenRace\RJWCompat\Source\RJWCompat\UI\Dialog_SelectRjwInteraction.cs
=
.
﻿using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Verse;
using Verse.AI;
using RimWorld;
using rjw; // 确保引用RJW
using rjw.Modules.Interactions;

namespace RavenRace.RJWCompat.UI
{
    /// <summary>
    /// 一个自定义的对话框窗口，用于选择RJW的性爱互动。
    /// 它取代了原有的FloatMenu，提供了分类和更好的用户体验，并解决了时序问题。
    /// </summary>
    public class Dialog_SelectRjwInteraction : Window
    {
        // 窗口尺寸
        private Vector2 scrollPosition = Vector2.zero;
        public override Vector2 InitialSize => new Vector2(480f, 640f);

        // 参与者
        private readonly Pawn caster;
        private readonly Pawn target;

        // 分类后的互动列表
        private readonly Dictionary<string, List<InteractionDef>> categorizedInteractions;

        // 构造函数
        public Dialog_SelectRjwInteraction(Pawn caster, Pawn target)
        {
            this.caster = caster;
            this.target = target;

            // 窗口属性
            forcePause = true;        // 强制暂停游戏，解决时序问题
            absorbInputAroundWindow = true; // 吸收窗口外的点击
            closeOnClickedOutside = true;

            // 获取并分类所有可用的互动
            categorizedInteractions = GetAndCategorizeInteractions();
        }

        /// <summary>
        /// 绘制窗口内容的核心方法
        /// </summary>
        public override void DoWindowContents(Rect inRect)
        {
            // 标题
            Text.Font = GameFont.Medium;
            Widgets.Label(new Rect(inRect.x, inRect.y, inRect.width, 40f), $"选择对 {target.LabelShortCap} 的互动方式");
            Text.Font = GameFont.Small;

            // 滚动视图区域
            Rect scrollRect = new Rect(inRect.x, inRect.y + 45f, inRect.width, inRect.height - 45f);
            float viewHeight = CalculateViewHeight(); // 动态计算内容高度
            Rect viewRect = new Rect(0f, 0f, scrollRect.width - 16f, viewHeight);

            Widgets.BeginScrollView(scrollRect, ref scrollPosition, viewRect);

            Listing_Standard listing = new Listing_Standard();
            listing.Begin(viewRect);

            // 绘制每个分类
            if (categorizedInteractions.NullOrEmpty())
            {
                listing.Label("没有找到可用的RJW互动。");
            }
            else
            {
                foreach (var category in categorizedInteractions.OrderBy(kvp => kvp.Key))
                {
                    listing.GapLine(12f);
                    listing.Label($"-- {category.Key} --"); // 分类标题
                    listing.Gap(4f);

                    foreach (var interaction in category.Value)
                    {
                        if (listing.ButtonText(interaction.LabelCap))
                        {
                            // 玩家点击按钮后，执行操作并关闭窗口
                            StartRjwSexJob(caster, target, interaction);
                            Close();
                        }
                    }
                }
            }

            listing.End();
            Widgets.EndScrollView();
        }

        /// <summary>
        /// 获取所有可用的RJW互动，并进行分类。
        /// </summary>
        private Dictionary<string, List<InteractionDef>> GetAndCategorizeInteractions()
        {
            var allRjwInteractions = DefDatabase<InteractionDef>.AllDefs
                .Where(def => def.HasModExtension<SexInteractionExtension>())
                .ToList();

            var validInteractions = new List<InteractionDef>();

            // 将 isRape 设为 true 来获取最广泛的互动列表，因为某些互动只在特定条件下可用。
            // 最终我们使用的是非强奸的 Job，所以这只是为了获取选项。
            SexProps props = new SexProps { pawn = caster, partner = target, isRape = true };
            var cache = new SexInteractionFinder.Internal.FinderCache(props);

            foreach (var interactionDef in allRjwInteractions)
            {
                var extension = interactionDef.GetModExtension<SexInteractionExtension>();
                if (extension == null) continue;

                bool initiatorSatisfied = SexInteractionFinder.Internal.TrySatisfyRequirement(caster, cache.initiatorParts, extension.initiatorRequirement, props, out _);
                bool recipientSatisfied = SexInteractionFinder.Internal.TrySatisfyRequirement(target, cache.recipientParts, extension.recipientRequirement, props, out _);

                if (initiatorSatisfied && recipientSatisfied)
                {
                    validInteractions.Add(interactionDef);
                }
            }

            var result = new Dictionary<string, List<InteractionDef>>();
            foreach (var interaction in validInteractions.OrderBy(i => i.label))
            {
                string category = GetCategoryFor(interaction);

                if (!result.ContainsKey(category))
                {
                    result[category] = new List<InteractionDef>();
                }
                result[category].Add(interaction);
            }
            return result;
        }

        /// <summary>
        /// 根据互动定义获取其分类。
        /// </summary>
        private string GetCategoryFor(InteractionDef def)
        {
            var sexInteraction = new SexInteraction(def);
            switch (sexInteraction.Sextype)
            {
                case xxx.rjwSextype.Vaginal: return "常规性交";
                case xxx.rjwSextype.Anal: return "逆向性交";
                case xxx.rjwSextype.Oral:
                case xxx.rjwSextype.Fellatio:
                case xxx.rjwSextype.Cunnilingus:
                case xxx.rjwSextype.Rimming:
                case xxx.rjwSextype.Sixtynine: return "口部性交";
                case xxx.rjwSextype.Boobjob: return "乳交";
                case xxx.rjwSextype.Handjob:
                case xxx.rjwSextype.Footjob:
                case xxx.rjwSextype.Fingering: return "手/足/指交";
                case xxx.rjwSextype.DoublePenetration: return "双重渗透";
                case xxx.rjwSextype.Fisting: return "拳交";
                default: return "其他互动";
            }
        }

        /// <summary>
        /// 计算滚动视图内容的总高度
        /// </summary>
        private float CalculateViewHeight()
        {
            float height = 0f;
            if (categorizedInteractions.NullOrEmpty()) return 30f;

            const float buttonHeight = 30f;
            const float categoryHeaderHeight = 24f;
            const float gapHeight = 16f;

            foreach (var category in categorizedInteractions)
            {
                height += categoryHeaderHeight + gapHeight + (category.Value.Count * buttonHeight);
            }
            return height + 12f;
        }

        /// <summary>
        /// 创建并分配一个在机制上是“自愿”的性爱Job，以避免关系惩罚。
        /// </summary>
        private void StartRjwSexJob(Pawn pawn, Pawn partner, InteractionDef selectedInteraction)
        {
            // [最终解决方案] 使用 "Quickie" 这个自愿的、不需要床的 JobDef。
            var jobDef = DefDatabase<JobDef>.GetNamed("Quickie");
            if (jobDef == null)
            {
                Log.Error("[RavenRace RJWCompat] Cannot find JobDef named 'Quickie'. This is a standard RJW JobDef.");
                return;
            }

            // ========================================================================
            // 【核心修正】 RJW 的 Quickie 工作逻辑会检查 FailOn(() => pawn.Drafted)。
            // 因此，如果玩家处于征召状态（通常使用技能时都是），必须先取消征召。
            // ========================================================================
            if (pawn.Drafted)
            {
                pawn.drafter.Drafted = false;
            }

            // 同时为了防止目标乱跑或还在战斗，也强制停止目标的工作
            // 如果目标被征召，也尝试取消征召（如果是玩家单位）
            if (partner.IsColonistPlayerControlled && partner.Drafted)
            {
                partner.drafter.Drafted = false;
            }
            partner.jobs.StopAll(); // 强行打断，让目标准备好接受互动

            // 创建Job实例。Quickie的目标是伴侣。
            Job job = JobMaker.MakeJob(jobDef, partner);

            // [关键] 通过job.interaction字段，将玩家选择的互动方式安全地传递给RJW的JobDriver。
            // JobDriver_SexQuick会读取这个字段，并自己生成一个 isRape = false 的 SexProps。
            job.interaction = selectedInteraction;

            Log.Message($"[RavenRace RJWCompat] Player selected '{selectedInteraction.defName}'. Force-undrafted and assigning RJW's 'Quickie' job to {pawn.LabelShort}.");

            // 分配Job
            pawn.jobs.TryTakeOrderedJob(job, JobTag.Misc);
        }
    }
}.
.
